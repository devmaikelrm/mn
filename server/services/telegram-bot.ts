import TelegramBot from 'node-telegram-bot-api';
import { config } from '../config';
import { createLogger } from './logger';
import { storage } from '../storage';
import { attFlow } from './att-flow';
import { statusChecker } from './status-checker';
import { insertUnlockRequestSchema, statusCheckSchema, RequestStatus } from '@shared/schema';

const logger = createLogger('telegram-bot');

export class TelegramBotService {
  private bot: TelegramBot;
  private isRunning = false;

  constructor() {
    this.bot = new TelegramBot(config.BOT_TOKEN, { polling: false });
    this.setupCommands();
  }

  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Bot is already running');
      return;
    }

    try {
      await this.bot.startPolling();
      this.isRunning = true;
      logger.info('Telegram bot started successfully');
    } catch (error: any) {
      logger.error(`Failed to start bot: ${error.message}`);
      throw error;
    }
  }

  async stop(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    try {
      await this.bot.stopPolling();
      this.isRunning = false;
      logger.info('Telegram bot stopped');
    } catch (error: any) {
      logger.error(`Error stopping bot: ${error.message}`);
    }
  }

  private setupCommands(): void {
    // Start command
    this.bot.onText(/\/start/, (msg: any) => {
      this.handleCommand(msg, () => this.handleStart(msg));
    });

    // Submit request command
    this.bot.onText(/\/solicitar (.+)/, (msg: any, match: any) => {
      this.handleCommand(msg, () => this.handleSolicitar(msg, match?.[1] || ''));
    });

    // Status check command
    this.bot.onText(/\/status (.+)/, (msg: any, match: any) => {
      this.handleCommand(msg, () => this.handleStatus(msg, match?.[1] || ''));
    });

    // Help command
    this.bot.onText(/\/help/, (msg: any) => {
      this.handleCommand(msg, () => this.handleStart(msg));
    });

    // Handle any other message
    this.bot.on('message', (msg: any) => {
      if (!msg.text?.startsWith('/')) {
        this.handleCommand(msg, () => this.handleUnknown(msg));
      }
    });

    // Handle callback queries (button presses)
    this.bot.on('callback_query', (query: any) => {
      this.handleCallbackQuery(query);
    });
  }

  private async handleCommand(msg: TelegramBot.Message, handler: () => Promise<void>): Promise<void> {
    const chatId = msg.chat.id.toString();
    const username = msg.from?.username || 'unknown';

    // Check if user is authorized
    if (chatId !== config.OWNER_ID) {
      logger.warn(`Unauthorized access attempt from ${username} (${chatId})`);
      await this.bot.sendMessage(chatId, 'üîí Este bot es privado. Solo el propietario autorizado puede usarlo.');
      return;
    }

    try {
      await handler();
    } catch (error: any) {
      logger.error(`Command handler error: ${error.message}`, undefined, { chatId, error: error.stack });
      await this.bot.sendMessage(chatId, '‚ùå Error interno del bot. Revisa los logs para m√°s detalles.');
    }
  }

  private async handleStart(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    const helpText = `
ü§ñ *AT&T Device Unlock Bot*

¬°Bienvenido! Utiliza los botones de abajo para una experiencia m√°s f√°cil, o escribe los comandos directamente.

*Comandos disponibles:*

üì± */solicitar* - Nueva solicitud de desbloqueo
üìä */status* - Consultar estado de solicitud
‚ùì */help* - Mostrar esta ayuda

*Formatos de comandos:*
‚Ä¢ \`/solicitar IMEI, Nombre Apellido, correo@email.com\`
‚Ä¢ \`/solicitar NUMERO_ATT, IMEI, Nombre Apellido, correo@email.com\`
‚Ä¢ \`/status IMEI, REQUEST_ID\`

‚ö†Ô∏è *Informaci√≥n importante:*
‚Ä¢ Proceso puede tomar hasta 24 horas
‚Ä¢ Si aparece CAPTCHA, se requerir√° intervenci√≥n manual
‚Ä¢ Los datos no se almacenan permanentemente

*Disclaimer:* Este bot automatiza el portal oficial de AT&T. La decisi√≥n final es √∫nicamente de AT&T.
    `;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üì± Nueva Solicitud', callback_data: 'help_solicitar' },
          { text: 'üìä Consultar Estado', callback_data: 'help_status' }
        ],
        [
          { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' },
          { text: '‚ùì Ayuda Completa', callback_data: 'show_help' }
        ],
        [
          { text: 'üåê Portal AT&T', url: 'https://www.att.com/deviceunlock' }
        ]
      ]
    };

    await this.bot.sendMessage(chatId, helpText, { 
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  private async handleSolicitar(msg: TelegramBot.Message, args: string): Promise<void> {
    const chatId = msg.chat.id;

    try {
      // Parse arguments
      const request = this.parseSubmissionArgs(args);

      // Validate request
      const validatedRequest = insertUnlockRequestSchema.parse(request);

      await this.bot.sendMessage(chatId, 'üîÑ Procesando solicitud de desbloqueo...');

      // Submit to AT&T
      const result = await attFlow.submitUnlockRequest(validatedRequest);

      // Store request in database
      const storedRequest = await storage.createUnlockRequest({
        ...validatedRequest,
        requestId: result.requestId || null,
        status: result.success ? RequestStatus.PENDING : RequestStatus.UNKNOWN,
        captchaDetected: result.captchaDetected,
        errorMessage: result.errorMessage || null,
      });

      // Send response
      if (result.success) {
        let responseText = '‚úÖ *Solicitud enviada exitosamente*\n\n';
        
        if (result.requestId) {
          responseText += `üìã *Request ID:* \`${result.requestId}\`\n`;
        }
        
        responseText += `üì± *IMEI:* \`${validatedRequest.imei.substring(0, 6)}...${validatedRequest.imei.substring(-4)}\`\n`;
        responseText += `üìß *Email:* ${validatedRequest.email}\n`;
        responseText += `‚è∞ *Vencimiento aproximado:* ${new Date(Date.now() + 24 * 60 * 60 * 1000).toLocaleString('es-MX')}\n\n`;
        responseText += 'üì¨ Revisa tu correo electr√≥nico para recibir actualizaciones de AT&T.';
        
        const successKeyboard = {
          inline_keyboard: [
            [
              { text: 'üìä Consultar Estado', callback_data: `check_status_${result.requestId}` },
              { text: 'üì± Nueva Solicitud', callback_data: 'help_solicitar' }
            ],
            [
              { text: 'üîÑ Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };
        
        await this.bot.sendMessage(chatId, responseText, { 
          parse_mode: 'Markdown',
          reply_markup: successKeyboard
        });
      } else if (result.captchaDetected) {
        const captchaKeyboard = {
          inline_keyboard: [
            [
              { text: 'üîÑ Intentar de Nuevo', callback_data: 'help_solicitar' },
              { text: 'üåê Portal AT&T', url: 'https://www.att.com/deviceunlock' }
            ],
            [
              { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };
        
        await this.bot.sendMessage(chatId, 
          'üîê *CAPTCHA Detectado*\n\n' +
          'Se detect√≥ un CAPTCHA en el portal de AT&T. Es necesaria la intervenci√≥n manual.\n\n' +
          'Puedes intentar nuevamente m√°s tarde o visitar directamente el portal de AT&T.',
          { 
            parse_mode: 'Markdown',
            reply_markup: captchaKeyboard
          }
        );
      } else {
        const errorKeyboard = {
          inline_keyboard: [
            [
              { text: 'üîÑ Intentar de Nuevo', callback_data: 'help_solicitar' },
              { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' }
            ],
            [
              { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };
        
        await this.bot.sendMessage(chatId, 
          `‚ùå *Error en la solicitud*\n\n${result.errorMessage || 'Error desconocido'}`,
          { 
            parse_mode: 'Markdown',
            reply_markup: errorKeyboard
          }
        );
      }

    } catch (error: any) {
      if (error.issues) {
        // Validation error
        const errorMessages = error.issues.map((issue: any) => `‚Ä¢ ${issue.message}`).join('\n');
        const validationKeyboard = {
          inline_keyboard: [
            [
              { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' },
              { text: '‚ùì Ayuda', callback_data: 'help_solicitar' }
            ],
            [
              { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };
        
        await this.bot.sendMessage(chatId, 
          `‚ùå *Error de validaci√≥n:*\n\n${errorMessages}\n\n` +
          'Use el formato correcto:\n' +
          '`/solicitar IMEI, Nombre Apellido, correo@email.com`\n' +
          'o\n' +
          '`/solicitar NUMERO_ATT, IMEI, Nombre Apellido, correo@email.com`',
          { 
            parse_mode: 'Markdown',
            reply_markup: validationKeyboard
          }
        );
      } else {
        await this.bot.sendMessage(chatId, `‚ùå Error: ${error.message}`);
      }
    }
  }

  private async handleStatus(msg: TelegramBot.Message, args: string): Promise<void> {
    const chatId = msg.chat.id;

    try {
      // Parse arguments
      const { imei, requestId } = this.parseStatusArgs(args);

      // Validate
      const validated = statusCheckSchema.parse({ imei, requestId });

      await this.bot.sendMessage(chatId, 'üîç Consultando estado en el portal de AT&T...');

      // Check status
      const result = await statusChecker.checkStatus(validated.imei, validated.requestId);

      // Update stored request if found
      const storedRequest = await storage.getUnlockRequestByRequestId(validated.requestId);
      if (storedRequest) {
        await storage.updateUnlockRequest(storedRequest.id, {
          status: result.status,
          statusDetails: result.details || null,
          lastCheckedAt: new Date(),
        });
      }

      // Send response
      if (result.success) {
        const statusEmoji = {
          [RequestStatus.APPROVED]: '‚úÖ',
          [RequestStatus.PENDING]: '‚è≥',
          [RequestStatus.DENIED]: '‚ùå',
          [RequestStatus.UNKNOWN]: '‚ùì',
        }[result.status] || '‚ùì';

        const statusText = {
          [RequestStatus.APPROVED]: 'Aprobada',
          [RequestStatus.PENDING]: 'Pendiente',
          [RequestStatus.DENIED]: 'Denegada',
          [RequestStatus.UNKNOWN]: 'Desconocido',
        }[result.status] || 'Desconocido';

        let responseText = `${statusEmoji} *Estado de la solicitud*\n\n`;
        responseText += `üì± *IMEI:* \`${validated.imei.substring(0, 6)}...${validated.imei.substring(-4)}\`\n`;
        responseText += `üìã *Request ID:* \`${validated.requestId}\`\n`;
        responseText += `üìä *Estado:* ${statusText}\n\n`;
        
        if (result.details) {
          responseText += `üìù *Detalles:*\n${result.details}`;
        }

        const statusKeyboard = {
          inline_keyboard: [
            [
              { text: 'üîÑ Actualizar Estado', callback_data: `refresh_status_${validated.imei}_${validated.requestId}` },
              { text: 'üì± Nueva Solicitud', callback_data: 'help_solicitar' }
            ],
            [
              { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };

        await this.bot.sendMessage(chatId, responseText, { 
          parse_mode: 'Markdown',
          reply_markup: statusKeyboard
        });
      } else {
        const statusErrorKeyboard = {
          inline_keyboard: [
            [
              { text: 'üîÑ Intentar de Nuevo', callback_data: 'help_status' },
              { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' }
            ],
            [
              { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };
        
        await this.bot.sendMessage(chatId, 
          `‚ùå *Error al consultar estado*\n\n${result.errorMessage || 'Error desconocido'}`,
          { 
            parse_mode: 'Markdown',
            reply_markup: statusErrorKeyboard
          }
        );
      }

    } catch (error: any) {
      if (error.issues) {
        const errorMessages = error.issues.map((issue: any) => `‚Ä¢ ${issue.message}`).join('\n');
        const statusValidationKeyboard = {
          inline_keyboard: [
            [
              { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' },
              { text: '‚ùì Ayuda', callback_data: 'help_status' }
            ],
            [
              { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
            ]
          ]
        };
        
        await this.bot.sendMessage(chatId, 
          `‚ùå *Error de validaci√≥n:*\n\n${errorMessages}\n\n` +
          'Use el formato correcto:\n`/status IMEI, REQUEST_ID`',
          { 
            parse_mode: 'Markdown',
            reply_markup: statusValidationKeyboard
          }
        );
      } else {
        await this.bot.sendMessage(chatId, `‚ùå Error: ${error.message}`);
      }
    }
  }

  private async handleUnknown(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    
    const unknownKeyboard = {
      inline_keyboard: [
        [
          { text: 'üì± Nueva Solicitud', callback_data: 'help_solicitar' },
          { text: 'üìä Consultar Estado', callback_data: 'help_status' }
        ],
        [
          { text: '‚ùì Ver Ayuda', callback_data: 'show_help' }
        ]
      ]
    };
    
    await this.bot.sendMessage(chatId, 
      '‚ùì Comando no reconocido. Usa los botones de abajo o /start para ver los comandos disponibles.',
      { reply_markup: unknownKeyboard }
    );
  }

  private parseSubmissionArgs(args: string): any {
    const parts = args.split(',').map(part => part.trim());

    if (parts.length === 3) {
      // Format: IMEI, Name, Email
      return {
        imei: parts[0],
        firstName: parts[1].split(' ')[0],
        lastName: parts[1].split(' ').slice(1).join(' ') || parts[1].split(' ')[0],
        email: parts[2],
      };
    } else if (parts.length === 4) {
      // Format: Phone, IMEI, Name, Email
      return {
        phoneNumber: parts[0],
        imei: parts[1],
        firstName: parts[2].split(' ')[0],
        lastName: parts[2].split(' ').slice(1).join(' ') || parts[2].split(' ')[0],
        email: parts[3],
      };
    } else {
      throw new Error('Formato incorrecto. Use el formato especificado en /start');
    }
  }

  private parseStatusArgs(args: string): { imei: string; requestId: string } {
    const parts = args.split(',').map(part => part.trim());

    if (parts.length !== 2) {
      throw new Error('Formato incorrecto. Use: IMEI, REQUEST_ID');
    }

    return {
      imei: parts[0],
      requestId: parts[1],
    };
  }

  private async handleCallbackQuery(query: any): Promise<void> {
    const chatId = query.message.chat.id;
    const data = query.data;

    // Answer the callback query to stop loading indicator
    await this.bot.answerCallbackQuery(query.id);

    try {
      switch (data) {
        case 'help_solicitar':
          await this.showSolicitarHelp(chatId);
          break;
        case 'help_status':
          await this.showStatusHelp(chatId);
          break;
        case 'show_examples':
          await this.showExamples(chatId);
          break;
        case 'show_help':
          // Create a fake message object for handleStart
          const fakeMsg = { chat: { id: chatId } } as TelegramBot.Message;
          await this.handleStart(fakeMsg);
          break;
        default:
          if (data.startsWith('check_status_') || data.startsWith('refresh_status_')) {
            await this.handleQuickStatus(chatId, data);
          }
          break;
      }
    } catch (error: any) {
      logger.error(`Callback query error: ${error.message}`);
      await this.bot.sendMessage(chatId, '‚ùå Error procesando la acci√≥n. Intenta nuevamente.');
    }
  }

  private async showSolicitarHelp(chatId: number): Promise<void> {
    const helpText = `
üì± *C√≥mo enviar una solicitud*

Usa el comando */solicitar* seguido de los datos separados por comas:

*Formato 1:* IMEI, Nombre Apellido, correo@email.com
*Formato 2:* NUMERO_ATT, IMEI, Nombre Apellido, correo@email.com

*Importante:*
‚Ä¢ IMEI debe tener 15 d√≠gitos
‚Ä¢ N√∫mero AT&T debe tener 10 d√≠gitos (si lo proporcionas)
‚Ä¢ Email debe ser v√°lido
‚Ä¢ Separar cada campo con coma y espacio

¬øNecesitas m√°s ayuda?`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' },
          { text: 'üìä Consultar Estado', callback_data: 'help_status' }
        ],
        [
          { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
        ]
      ]
    };

    await this.bot.sendMessage(chatId, helpText, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  private async showStatusHelp(chatId: number): Promise<void> {
    const helpText = `
üìä *C√≥mo consultar el estado*

Usa el comando */status* seguido de los datos separados por comas:

*Formato:* IMEI, REQUEST_ID

*Importante:*
‚Ä¢ IMEI debe tener 15 d√≠gitos
‚Ä¢ REQUEST_ID es el c√≥digo que recibiste al crear la solicitud
‚Ä¢ Separar con coma y espacio

El bot consultar√° autom√°ticamente el portal de AT&T para obtener el estado actual.`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' },
          { text: 'üì± Nueva Solicitud', callback_data: 'help_solicitar' }
        ],
        [
          { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
        ]
      ]
    };

    await this.bot.sendMessage(chatId, helpText, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  private async showExamples(chatId: number): Promise<void> {
    const helpText = `
üìã *Ejemplos de uso*

*Para enviar solicitud (sin n√∫mero AT&T):*
\`/solicitar 353012345678901, Juan P√©rez, juan@email.com\`

*Para enviar solicitud (con n√∫mero AT&T):*
\`/solicitar 1234567890, 353012345678901, Mar√≠a Garc√≠a, maria@email.com\`

*Para consultar estado:*
\`/status 353012345678901, NUL117557332822\`

*Notas importantes:*
‚Ä¢ Respeta las comas y espacios exactamente como se muestra
‚Ä¢ El IMEI siempre tiene 15 d√≠gitos
‚Ä¢ El n√∫mero AT&T tiene 10 d√≠gitos (opcional)
‚Ä¢ El REQUEST_ID lo recibes al crear la solicitud`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üì± Nueva Solicitud', callback_data: 'help_solicitar' },
          { text: 'üìä Consultar Estado', callback_data: 'help_status' }
        ],
        [
          { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
        ]
      ]
    };

    await this.bot.sendMessage(chatId, helpText, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  private async handleQuickStatus(chatId: number, data: string): Promise<void> {
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Ver Ejemplos', callback_data: 'show_examples' },
          { text: '‚ùì Ayuda Status', callback_data: 'help_status' }
        ],
        [
          { text: 'üè† Volver al Men√∫', callback_data: 'show_help' }
        ]
      ]
    };

    await this.bot.sendMessage(chatId, 
      'üìä *Consulta r√°pida de estado*\n\n' +
      'Para consultar el estado, usa:\n' +
      '`/status IMEI, REQUEST_ID`\n\n' +
      'Ejemplo:\n' +
      '`/status 353012345678901, NUL117557332822`', 
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }
}

export const telegramBot = new TelegramBotService();
